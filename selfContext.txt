using stub to check if the compiler is called on each execution

$filter is to directlty filter out contents - if needed to transform we must use $type and call $tranform within that

The direct filters usually represent each set of json (for each objects in the array)
eg:In array1: [ { a: 1, b: 'x' } , { a: 2, b: 'y' }, { a: 3, b: 'z' } ], Here {a:1, b:x} is one set of json(first array object)
So The filer will be [{a: number},{b: string}] -  this will be applied across all array objects


If using explicit initial context - The values sent in target will get replaced by input values that passes the filter - based on the array index
Suppose if 
123456 is the target and in input if we have 
789 - If 8 gets filtered out and only 7 and 9 passess, the output will be 
729456

You filter the keys and tranform an whole object - filter is used to filter the values of an object or array - transform is used to convert the whole object
{a:{one:1,two:2},b:{four:4,five:5}}
In the above example - we can iterate through the values of a and b using filter but cannot iterate as whole key:value pair 
To do that we have to use transform to modify the whole object


Scenarios:
Regression:
- before:
    - Add filters to jsxl - using useFilters()
    - compile multiple filters - using compileMultiple() - useFilter already compiles the filters no need to do it again
- Test:
    - execute multiple times using different filters
    - compile again using different filter(directly call jsxl) - execute 
    - execute again using the previously added filter

- before:
    - add a filter and tranform function
- Test:
    - perform validation by setting an explicit context

- before:
    - add a filter with many modifiers
- Test:
    - compile and execute


Have a set of regression scripts - these will include generic functionality scenarios.
Then have Seperate test cases based on the features:
- filters - using multiple
- transform
- modifiers
- context - explicit context
- merge




To do:
- split the input, filter and output into smaller samples - and form sets
- develop various inputs and filters to test all the possibilities and working of each modifiers
        - Create inputs and filter for all other modifiers using boundary values
        - Create filters and inputs to reproduce various errors:
            - next() loop
            - map modifier - data not present
            - $filter - boolean error
            


- using insert at the top level
- Full positive flow - changing and inserting values
- pass different values directly - null, undefined, function, 0 , infinity
- use $filter and $insert together
- use $insert along with $remove and $default



- verify transform overides default
- use default to insert values tha are not present in input or undefined
- use default to insert key and values that are not present in input or undefined
- pass different values directly - null, undefined, function, 0 , infinity
- use $filter and $insert together
- use $insert along with $remove and $default




